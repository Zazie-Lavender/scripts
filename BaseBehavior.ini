[script]
n0=#ProcessPriority on
n1=;Here is where we simply ask the OS to give us a little bit more processing power
n2=;This is to ensure better stability. This is optional and you may prevent it by typing 
n3=;'/disable #ProcessPriority'. You may also change the priority below to your desired level
n4=;to set performance levels to suit your computing situations.
n5=on *:start {
n6=  run wmic process where name="mirc.exe" CALL setpriority "above normal"
n7=}
n8=#ProcessPriority end
n9=
n10=;;Here we just redirect /notices to the active window and handle special cases like ##werewolf's where we want bot notices to also be added 
n11=;;to a window
n12=#noticehandler on
n13=on ^SVS:notice:*:?: { 
n14=  window -Die2k0 @Services 
n15=  aline -p @Services < $network $+ : $+ $nick > $1-
n16=  echo -s --> < $+ $nick $+ > $1-
n17=  haltdef
n18=}
n19=on ^1:notice:*:?: { 
n20=  ;if (serv isin $nick) { halt }
n21=  if ($active == @Services) { 
n22=    goto noact
n23=  }
n24=  echo -a --> < $+ $nick $+ > $1-
n25=  :noact
n26=  if ($nick == %wolfnick) { /wn <lykos> $1- }
n27=  haltdef
n28=}
n29=
n30=on ^*:text:*:?:{ 
n31=  if ($nick == %safenick) { aline -p @safepm $nick > $1- }
n32=}
n33=
n34=raw ACCOUNT:*: { 
n35=  aline -p @snotices $timestamp $+(<,$network,>) $nick is now identified to account $1  
n36=  haltdef
n37=}
n38=
n39=on ^*:SNOTICE:*: { 
n40=  if ($window(@snotices) != @snotices) { window -Dk1l25e2 @snotices }
n41=  if (NICK isincs $2) {
n42=    var %c = $r(2,13)
n43=    aline -p %c @snotices $timestamp $+(<,$network,>) $2-
n44=    aline -lpn %c @snotices $4
n45=    aline -lpn %c @snotices $9
n46=    halt
n47=  }
n48=  aline -p @snotices $timestamp $1-
n49=  echo -s > $1-
n50=  if (OPER isincs $2) {
n51=    aline -lpn @snotices $+(!,$3)
n52=  }
n53=  ;;else { echo -s $1- }
n54=  haltdef
n55=}
n56=;; aline -lpn @snotices $2
n57=#noticehandler end
n58=
n59=;; % [ $+ [ $# ] ] (for appending together variables)
n60=;;This is where we handle raw IRC numerics and route them appropriately. For example we want to suppress certain events and keep them from spamming
n61=;;the server windows with extra information we don't really need.
n62=#rawhandlers on
n63=;;Cache the version reply so we can match against it later and define script behaviors based on ircd behavior by matching against
n64=;;the server's own version reply as some servers may reply differently or have different behaviors for commands.
n65=raw 351:*: { 
n66=  unset % [ $+ [ $network ] ]
n67=  set % [ $+ [ $network ] ] $1-
n68=}
n69=raw 005:*: {
n70=  set % [ $+ [ $network ] ] % [ $+ [ $network ] ] $1- 
n71=}
n72=;;stop NAMES spamming the server window...we're also caching it in a hashtable as well so we can search against it later.
n73=;;on ^*:join:#: { names $chan } ;;update names list on join
n74=raw 353:*: { 
n75=  ;;echo -s $1-
n76=  hinc -m [ $+($cid,.,$3) ] i
n77=  hadd -m [ $+($cid,.,$3) ] [ NameBuffer $+ [ $hget($+($cid,.,$3),i) ] ] $4-
n78=  haltdef
n79=}
n80=raw 366:*: {
n81=  haltdef 
n82=}
n83=
n84=;;Ping times to server.
n85=on *:connect: { 
n86=  timer 0 60 /tickping 
n87=  window -k2l20 $+(@lag,$network)
n88=}
n89=on ^*:PONG: { 
n90=  if ($1 == $server) {
n91=    aline -p $+(@lag,$network) $timestamp RTT(Ticks): $calc($ticks - $2) RTT(Sec): $calc($calc($ticks - $2) / 1000) 
n92=    aline -lp $+(@lag,$network) $timestamp $calc($calc($ticks - $2) / 1000)
n93=    set [ %lag $+ [ $network ] ] $calc($calc($ticks - $2) / 1000)
n94=  }
n95=  haltdef
n96=}
n97=
n98=
n99=;;Better Error handling, so we know when we accidentally send a command the server doesn't understand. 
n100=;;We may also try to shoehorn in some sort of lagtime measurements here, but I don't see why we should as /ping and server's pong works too
n101=raw 421:*: { 
n102=  echo -a ( Server ) 421: $2 $+ : $3-
n103=  haltdef
n104=}
n105=
n106=;;caching names data
n107=alias nametable {
n108=  var %i $hget($+($cid,.,$$1),i)
n109=  while (%i > 0) {
n110=    echo -a $$1 > $+(#,%i) > $+(NameBuffer,%i) > $hget($+($cid,.,$$1),$+(NameBuffer,%i))
n111=    dec %i
n112=  }
n113=}
n114=
n115=alias ntn {
n116=  if (isid) { 
n117=    return $hget($+($cid,.,$$1),$+(NameBuffer,$$2)) 
n118=    halt
n119=  }
n120=  echo -a $$1 > $$2 > $+(NameBuffer,$$2) > $hget($+($cid,.,$$1),$+(NameBuffer,$$2))
n121=}
n122=#rawhandlers end
n123=
n124=
n125=;; Smarter handling of sticky channels. We tell the client to send /detach for stuck chans. This gets us *out* of the channel quietly.
n126=;; Obviously, if you stick a channel; it must be added to %sticky so we know which channels to behave this way too. We may actually 
n127=;; need to add a bouncer detection too; but this can come later and we can just copy %sticky to %oldsticky and unset %sticky if we're connecting 
n128=;; directly instead of with the bouncer like normal. or we could just use a group. 
n129=
n130=#ZNCTweaks on
n131=alias part {
n132=  if ($1 isin %sticky) {
n133=    /detach $1
n134=  }
n135=  else { part $1- }
n136=}
n137=
n138=on me:ctcpreply:ZNC*: {
n139=  echo -a reply > $1-
n140=  if ($1) {
n141=    echo -a ZNC Detected!
n142=  }
n143=}
n144=#ZNCTweaks end
n145=
n146=#MassCommands on
n147=alias d {
n148=  detach $$1
n149=  var %i = $wildtok($1-,*,0,32)
n150=  while (%i > 1) {
n151=    detach [ [ $+($$,%i) ] ]
n152=    dec %i
n153=  }
n154=}
n155=
n156=alias j {
n157=  join $$1
n158=  var %i = $wildtok($1-,*,0,32)
n159=  while (%i > 1) {
n160=    join [ [ $+($$,%i) ] ]
n161=    dec %i
n162=  }
n163=}
n164=
n165=alias mv {
n166=  mode $chan $+(+,$str(v,4)) $$1-4
n167=  var %i = $wildtok($1-,*,0,32)
n168=  while (%i > 4) {
n169=    mode $chan +v [ [ $+($$,%i,-,$calc(%i-4)) ] ] 
n170=    dec %i
n171=  }
n172=}
n173=
n174=alias msamode {
n175=  var %i = $wildtok($1-,*,0,32)
n176=  while (%i > 0) {
n177=    samode [ [ $+($$,%i) ] ] +R
n178=    dec %i
n179=  }
n180=}
n181=
n182=
n183=alias mdv {
n184=  mode $chan $+(-,$str(v,4)) $$1-4
n185=  var %i = $wildtok($1-,*,0,32)
n186=  while (%i > 4) {
n187=    mode $chan -v [ [ $+($$,%i,-,$calc(%i-4)) ] ]
n188=    dec %i
n189=  }
n190=}
n191=
n192=alias m+y {
n193=  mode $chan $+(+,$str(y,4)) $$1-4
n194=  var %i = $wildtok($1-,*,0,32)
n195=  while (%i > 4) {
n196=    mode $chan +y [ [ $+($$,%i,-,$calc(%i-4)) ] ]
n197=    dec %i
n198=  }
n199=}
n200=
n201=alias m-y {
n202=  mode $chan $+(-,$str(y,4)) $$1-4
n203=  var %i = $wildtok($1-,*,0,32)
n204=  while (%i > 4) {
n205=    mode $chan -y [ [ $+($$,%i,-,$calc(%i-4)) ] ]
n206=    dec %i
n207=  }
n208=}
n209=
n210=alias mq {
n211=  mode $chan $+(+,$str(q,4)) $$1-4
n212=  var %i = $wildtok($1-,*,0,32)
n213=  while (%i > 4) {
n214=    mode $chan +q [ [ $+($$,%i,-,$calc(%i-4)) ] ]
n215=    dec %i
n216=  }
n217=}
n218=
n219=alias mdq {
n220=  mode $chan $+(-,$str(q,4)) $$1-4
n221=  var %i = $wildtok($1-,*,0,32)
n222=  while (%i > 4) {
n223=    mode $chan -q [ [ $+($$,%i,-,$calc(%i-4)) ] ]
n224=    dec %i
n225=  }
n226=}
n227=
n228=alias ma {
n229=  mode $chan $+(+,$str(a,4)) $$1-4
n230=  var %i = $wildtok($1-,*,0,32)
n231=  while (%i > 4) {
n232=    mode $chan +a [ [ $+($$,%i,-,$calc(%i-4)) ] ]
n233=    dec %i
n234=  }
n235=}
n236=
n237=alias mda {
n238=  mode $chan $+(-,$str(a,4)) $$1-4
n239=  var %i = $wildtok($1-,*,0,32)
n240=  while (%i > 4) {
n241=    mode $chan -a [ [ $+($$,%i,-,$calc(%i-4)) ] ]
n242=    dec %i
n243=  }
n244=}
n245=
n246=alias mo {
n247=  mode $chan $+(+,$str(o,4)) $$1-4
n248=  var %i = $wildtok($1-,*,0,32)
n249=  while (%i > 4) {
n250=    mode $chan +o [ [ $+($$,%i,-,$calc(%i-4)) ] ]
n251=    dec %i
n252=  }
n253=}
n254=
n255=alias mdo {
n256=  mode $chan $+(-,$str(o,4)) $$1-4
n257=  var %i = $wildtok($1-,*,0,32)
n258=  while (%i > 4) {
n259=    mode $chan -o [ [ $+($$,%i,-,$calc(%i-4)) ] ]
n260=    dec %i
n261=  }
n262=}
n263=
n264=alias mh {
n265=  mode $chan $+(+,$str(h,4)) $$1-4
n266=  var %i = $wildtok($1-,*,0,32)
n267=  while (%i > 4) {
n268=    mode $chan +h [ [ $+($$,%i,-,$calc(%i-4)) ] ]
n269=    dec %i
n270=  }
n271=}
n272=
n273=alias mdq {
n274=  mode $chan $+(-,$str(h,4)) $$1-4
n275=  var %i = $wildtok($1-,*,0,32)
n276=  while (%i > 4) {
n277=    mode $chan -h [ [ $+($$,%i,-,$calc(%i-4)) ] ]
n278=    dec %i
n279=  }
n280=}
n281=
n282=alias mm {
n283=  var %i = $wildtok($2-,*,0,32)
n284=  while (%i > 1) {
n285=    mode $chan [ $+(+,$1) ] [ [ $+($$,%i) ] ]
n286=    dec %i
n287=  }
n288=}
n289=
n290=alias mdm {
n291=  var %i = $wildtok($1-,*,0,32)
n292=  while (%i > 1) {
n293=    mode $chan [ $+(-,$1) ] [ [ $+($$,%i) ] ]
n294=    dec %i
n295=  }
n296=}
n297=#MassCommands end
n298=
n299=#Notifyfix on
n300=alias monitor {
n301=  if ($network isin %nomon) {
n302=    watch $1-
n303=  }
n304=  else { monitor $1- }
n305=}
n306=
n307=#Notifyfix end
n308=
n309=#umodeghandler on
n310=;;Auto-accept users on voice in ##werewolf. 
n311=on ^*:voice:##werewolf: {
n312=  if ($vnick isin [ % $+ [ $network $+ . $+ accept ] ]) { halt }
n313=  /accept $vnick 
n314=  /accept *
n315=}
n316=;;Opers have auto /accept
n317=on ^*:voice:#freenode: {
n318=  if ($vnick isin [ % $+ [ $network $+ . $+ accept ] ]) { halt }
n319=  /accept $vnick 
n320=  /accept *
n321=}
n322=;;Freenode won't track nick changes for accept lists.
n323=on ^*:nick: { 
n324=  if ($newnick isin [ % $+ [ $network $+ . $+ accept ] ]) { halt }
n325=  if ($newnick isvoice ##werewolf) { /accept $newnick | /accept * }
n326=  if ($newnick isvoice #freenode) { /accept $newnick | /accept * }
n327=}
n328=raw 718:*: {
n329=  if ($2 ischan) { /accept $2 | /accept * }
n330=}
n331=raw 281:*: { set [ % $+ [ $network $+ . $+ accept ] ] $2- }
n332=#umodeghandler end
n333=
n334=#quietmodehandler on
n335=raw 728:*: { echo 7 $2 $+(+,$3) $4 by $5 on $asctime($6,mm/dd/yy @ hh:nn:sst) }
n336=raw 729:*: { echo 7 $2 $3- }
n337=#quietmodehandler end
