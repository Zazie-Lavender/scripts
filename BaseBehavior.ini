[script]
n0=#ProcessPriority on
n1=;Here is where we simply ask the OS to give us a little bit more processing power
n2=;This is to ensure better stability. This is optional and you may prevent it by typing 
n3=;'/disable #ProcessPriority'. You may also change the priority below to your desired level
n4=;to set performance levels to suit your computing situations.
n5=on *:start {
n6=  run wmic process where name="mirc.exe" CALL setpriority "above normal"
n7=}
n8=#ProcessPriority end
n9=
n10=;;Here we just redirect /notices to the active window and handle special cases like ##werewolf's where we want bot notices to also be added 
n11=;;to a window
n12=#noticehandler on
n13=on ^SVS:notice:*:?: { 
n14=  window -Die2k0 @Services 
n15=  aline -p @Services < $network $+ : $+ $nick > $1-
n16=  echo -s --> < $+ $nick $+ > $1-
n17=  haltdef
n18=}
n19=on ^1:notice:*:?: { 
n20=  ;if (serv isin $nick) { halt }
n21=  if ($active == @Services) { 
n22=    goto noact
n23=  }
n24=  echo -a --> < $+ $nick $+ > $1-
n25=  :noact
n26=  if ($nick == lykos) { /wn <lykos> $1- }
n27=  haltdef
n28=}
n29=
n30=on ^*:text:*:?:{ 
n31=  if ($nick == %safenick) { aline -p @safepm $nick > $1- }
n32=}
n33=on ^*:SNOTICE:*: { 
n34=  if ($window(@snotices) != @snotices) { window -Dk1l25e2 @snotices }
n35=  if (NICK isincs $2) {
n36=    var %c = $r(2,13)
n37=    aline -p %c @snotices $timestamp $1-
n38=    aline -lpn %c @snotices $4
n39=    aline -lpn %c @snotices $9
n40=    halt
n41=  }
n42=  aline -p @snotices $timestamp $1-
n43=  echo -s > $1-
n44=  if (OPER isincs $2) {
n45=    aline -lpn @snotices $+(!,$3)
n46=  }
n47=  haltdef
n48=}
n49=;; aline -lpn @snotices $2
n50=#noticehandler end
n51=
n52=;; % [ $+ [ $# ] ] (for appending together variables)
n53=;;This is where we handle raw IRC numerics and route them appropriately. For example we want to suppress certain events and keep them from spamming
n54=;;the server windows with extra information we don't really need.
n55=#rawhandlers on
n56=;;Cache the version reply so we can match against it later and define script behaviors based on ircd behavior by matching against
n57=;;the server's own version reply as some servers may reply differently or have different behaviors for commands.
n58=raw 005:*: {
n59=  set % [ $+ [ $network ] ] % [ $+ [ $network ] ] $1- 
n60=}
n61=;;stop NAMES spamming the server window...we're also caching it in a hashtable as well so we can search against it later.
n62=;;on ^*:join:#: { names $chan } ;;update names list on join
n63=raw 353:*: { 
n64=  ;;echo -s $1-
n65=  hinc -m [ $+($cid,.,$3) ] i
n66=  hadd -m [ $+($cid,.,$3) ] [ NameBuffer $+ [ $hget($+($cid,.,$3),i) ] ] $4-
n67=  haltdef
n68=}
n69=raw 366:*: {
n70=  haltdef 
n71=}
n72=
n73=;;Ping times to server.
n74=on *:connect: { 
n75=  timer 0 60 /tickping 
n76=  window -k2l17 $+(@lag,$network)
n77=}
n78=on ^*:PONG: { 
n79=  if ($1 == $server) {
n80=    aline -p $+(@lag,$network) $timestamp RTT(Ticks): $calc($ticks - $2) RTT(Sec): $calc($calc($ticks - $2) / 1000) 
n81=    aline -lp $+(@lag,$network) $timestamp $calc($calc($ticks - $2) / 1000)
n82=    set [ %lag $+ [ $network ] ] $calc($calc($ticks - $2) / 1000)
n83=  }
n84=  haltdef
n85=}
n86=
n87=^*:error:*: { haltdef }
n88=
n89=;;Better Error handling, so we know when we accidentally send a command the server doesn't understand. 
n90=;;We may also try to shoehorn in some sort of lagtime measurements here, but I don't see why we should as /ping and server's pong works too
n91=raw 421:*: { 
n92=  echo -a ( Server ) 421: $2 $+ : $3-
n93=  haltdef
n94=}
n95=
n96=;;caching names data
n97=alias nametable {
n98=  var %i $hget($+($cid,.,$$1),i)
n99=  while (%i > 0) {
n100=    echo -a $$1 > $+(#,%i) > $+(NameBuffer,%i) > $hget($+($cid,.,$$1),$+(NameBuffer,%i))
n101=    dec %i
n102=  }
n103=}
n104=
n105=alias ntn {
n106=  if (isid) { 
n107=    return $hget($+($cid,.,$$1),$+(NameBuffer,$$2)) 
n108=    halt
n109=  }
n110=  echo -a $$1 > $$2 > $+(NameBuffer,$$2) > $hget($+($cid,.,$$1),$+(NameBuffer,$$2))
n111=}
n112=#rawhandlers end
n113=
n114=
n115=;; Smarter handling of sticky channels. We tell the client to send /detach for stuck chans. This gets us *out* of the channel quietly.
n116=;; Obviously, if you stick a channel; it must be added to %sticky so we know which channels to behave this way too. We may actually 
n117=;; need to add a bouncer detection too; but this can come later and we can just copy %sticky to %oldsticky and unset %sticky if we're connecting 
n118=;; directly instead of with the bouncer like normal. or we could just use a group. 
n119=
n120=#ZNCTweaks on
n121=alias part {
n122=  if ($1 isin %sticky) {
n123=    /detach $1
n124=  }
n125=  else { part $1- }
n126=}
n127=
n128=on me:ctcpreply:ZNC*: {
n129=  echo -a reply > $1-
n130=  if ($1) {
n131=    echo -a ZNC Detected!
n132=  }
n133=}
n134=#ZNCTweaks end
n135=
n136=#MassCommands on
n137=alias d {
n138=  detach $$1
n139=  var %i = $wildtok($1-,*,0,32)
n140=  while (%i > 1) {
n141=    detach [ [ $+($$,%i) ] ]
n142=    dec %i
n143=  }
n144=}
n145=
n146=alias j {
n147=  join $$1
n148=  var %i = $wildtok($1-,*,0,32)
n149=  while (%i > 1) {
n150=    join [ [ $+($$,%i) ] ]
n151=    dec %i
n152=  }
n153=}
n154=
n155=alias mv {
n156=  mode $chan $+(+,$str(v,4)) $$1-4
n157=  var %i = $wildtok($1-,*,0,32)
n158=  while (%i > 4) {
n159=    mode $chan +v [ [ $+($$,%i,-,$calc(%i-4)) ] ] 
n160=    dec %i
n161=  }
n162=}
n163=
n164=alias mdv {
n165=  mode $chan $+(-,$str(v,4)) $$1-4
n166=  var %i = $wildtok($1-,*,0,32)
n167=  while (%i > 4) {
n168=    mode $chan -v [ [ $+($$,%i,-,$calc(%i-4)) ] ]
n169=    dec %i
n170=  }
n171=}
n172=
n173=alias m+y {
n174=  mode $chan $+(+,$str(y,4)) $$1-4
n175=  var %i = $wildtok($1-,*,0,32)
n176=  while (%i > 4) {
n177=    mode $chan +y [ [ $+($$,%i,-,$calc(%i-4)) ] ]
n178=    dec %i
n179=  }
n180=}
n181=
n182=alias m-y {
n183=  mode $chan $+(-,$str(y,4)) $$1-4
n184=  var %i = $wildtok($1-,*,0,32)
n185=  while (%i > 4) {
n186=    mode $chan -y [ [ $+($$,%i,-,$calc(%i-4)) ] ]
n187=    dec %i
n188=  }
n189=}
n190=
n191=alias mq {
n192=  mode $chan $+(+,$str(q,4)) $$1-4
n193=  var %i = $wildtok($1-,*,0,32)
n194=  while (%i > 4) {
n195=    mode $chan +q [ [ $+($$,%i,-,$calc(%i-4)) ] ]
n196=    dec %i
n197=  }
n198=}
n199=
n200=alias mdq {
n201=  mode $chan $+(-,$str(q,4)) $$1-4
n202=  var %i = $wildtok($1-,*,0,32)
n203=  while (%i > 4) {
n204=    mode $chan -q [ [ $+($$,%i,-,$calc(%i-4)) ] ]
n205=    dec %i
n206=  }
n207=}
n208=
n209=alias ma {
n210=  mode $chan $+(+,$str(a,4)) $$1-4
n211=  var %i = $wildtok($1-,*,0,32)
n212=  while (%i > 4) {
n213=    mode $chan +a [ [ $+($$,%i,-,$calc(%i-4)) ] ]
n214=    dec %i
n215=  }
n216=}
n217=
n218=alias mda {
n219=  mode $chan $+(-,$str(a,4)) $$1-4
n220=  var %i = $wildtok($1-,*,0,32)
n221=  while (%i > 4) {
n222=    mode $chan -a [ [ $+($$,%i,-,$calc(%i-4)) ] ]
n223=    dec %i
n224=  }
n225=}
n226=
n227=alias mo {
n228=  mode $chan $+(+,$str(o,4)) $$1-4
n229=  var %i = $wildtok($1-,*,0,32)
n230=  while (%i > 4) {
n231=    mode $chan +o [ [ $+($$,%i,-,$calc(%i-4)) ] ]
n232=    dec %i
n233=  }
n234=}
n235=
n236=alias mdo {
n237=  mode $chan $+(-,$str(o,4)) $$1-4
n238=  var %i = $wildtok($1-,*,0,32)
n239=  while (%i > 4) {
n240=    mode $chan -o [ [ $+($$,%i,-,$calc(%i-4)) ] ]
n241=    dec %i
n242=  }
n243=}
n244=
n245=alias mh {
n246=  mode $chan $+(+,$str(h,4)) $$1-4
n247=  var %i = $wildtok($1-,*,0,32)
n248=  while (%i > 4) {
n249=    mode $chan +h [ [ $+($$,%i,-,$calc(%i-4)) ] ]
n250=    dec %i
n251=  }
n252=}
n253=
n254=alias mdq {
n255=  mode $chan $+(-,$str(h,4)) $$1-4
n256=  var %i = $wildtok($1-,*,0,32)
n257=  while (%i > 4) {
n258=    mode $chan -h [ [ $+($$,%i,-,$calc(%i-4)) ] ]
n259=    dec %i
n260=  }
n261=}
n262=
n263=alias mm {
n264=  var %i = $wildtok($2-,*,0,32)
n265=  while (%i > 1) {
n266=    mode $chan [ $+(+,$1) ] [ [ $+($$,%i) ] ]
n267=    dec %i
n268=  }
n269=}
n270=
n271=alias mdm {
n272=  var %i = $wildtok($1-,*,0,32)
n273=  while (%i > 1) {
n274=    mode $chan [ $+(-,$1) ] [ [ $+($$,%i) ] ]
n275=    dec %i
n276=  }
n277=}
n278=#MassCommands end
n279=
n280=#Notifyfix on
n281=alias monitor {
n282=  if ($network isin %nomon) {
n283=    watch $1-
n284=  }
n285=  else { monitor $1- }
n286=}
n287=
n288=#Notifyfix end
n289=
n290=#umodeghandler on
n291=;;Auto-accept users on voice in ##werewolf. 
n292=on ^*:voice:##werewolf: {
n293=  if ($vnick isin [ % $+ [ $network $+ . $+ accept ] ]) { halt }
n294=  /accept $vnick 
n295=  /accept *
n296=}
n297=;;Opers have auto /accept
n298=on ^*:voice:#freenode: {
n299=  if ($vnick isin [ % $+ [ $network $+ . $+ accept ] ]) { halt }
n300=  /accept $vnick 
n301=  /accept *
n302=}
n303=;;Freenode won't track nick changes for accept lists.
n304=on ^*:nick: { 
n305=  if ($newnick isin [ % $+ [ $network $+ . $+ accept ] ]) { halt }
n306=  if ($newnick isvoice ##werewolf) { /accept $newnick | /accept * }
n307=  if ($newnick isvoice #freenode) { /accept $newnick | /accept * }
n308=}
n309=raw 718:*: {
n310=  if ($2 ischan) { /accept $2 | /accept * }
n311=}
n312=raw 281:*: { set [ % $+ [ $network $+ . $+ accept ] ] $2- }
n313=#umodeghandler end
n314=
n315=#quietmodehandler on
n316=raw 728:*: { echo 7 $2 $+(+,$3) $4 by $5 on $asctime($6,mm/dd/yy @ hh:nn:sst) }
n317=raw 729:*: { echo 7 $2 $3- }
n318=#quietmodehandler end
