[script]
n0=#ProcessPriority on
n1=;Here is where we simply ask the OS to give us a little bit more processing power
n2=;This is to ensure better stability. This is optional and you may prevent it by typing 
n3=;'/disable #ProcessPriority'. You may also change the priority below to your desired level
n4=;to set performance levels to suit your computing situations.
n5=on *:start {
n6=  run wmic process where name="mirc.exe" CALL setpriority "above normal"
n7=}
n8=#ProcessPriority end
n9=
n10=;;Here we just redirect /notices to the active window and handle special cases like ##werewolf's where we want bot notices to also be added 
n11=;;to a window
n12=#noticehandler on
n13=on ^SVS:notice:*:?: { 
n14=  window -Die2k0 @Services 
n15=  aline -p @Services < $network $+ : $+ $nick > $1-
n16=  echo -s --> < $+ $nick $+ > $1-
n17=  haltdef
n18=}
n19=on ^1:notice:*:?: { 
n20=  ;if (serv isin $nick) { halt }
n21=  if ($active == @Services) { 
n22=    goto noact
n23=  }
n24=  echo -a --> < $+ $nick $+ > $1-
n25=  :noact
n26=  if ($nick == %wolfnick) { /wn <lykos> $1- }
n27=  haltdef
n28=}
n29=
n30=on ^*:text:*:?:{ 
n31=  if ($nick == %safenick) { aline -p @safepm $nick > $1- }
n32=}
n33=on ^*:SNOTICE:*: { 
n34=  if ($window(@snotices) != @snotices) { window -Dk1l25e2 @snotices }
n35=  if (NICK isincs $2) {
n36=    var %c = $r(2,13)
n37=    aline -p %c @snotices $timestamp $+(<,$network,>) $2-
n38=    aline -lpn %c @snotices $4
n39=    aline -lpn %c @snotices $9
n40=    halt
n41=  }
n42=  aline -p @snotices $timestamp $1-
n43=  echo -s > $1-
n44=  if (OPER isincs $2) {
n45=    aline -lpn @snotices $+(!,$3)
n46=  }
n47=  ;;else { echo -s $1- }
n48=  haltdef
n49=}
n50=;; aline -lpn @snotices $2
n51=#noticehandler end
n52=
n53=;; % [ $+ [ $# ] ] (for appending together variables)
n54=;;This is where we handle raw IRC numerics and route them appropriately. For example we want to suppress certain events and keep them from spamming
n55=;;the server windows with extra information we don't really need.
n56=#rawhandlers on
n57=;;Cache the version reply so we can match against it later and define script behaviors based on ircd behavior by matching against
n58=;;the server's own version reply as some servers may reply differently or have different behaviors for commands.
n59=raw 351:*: { 
n60=  unset % [ $+ [ $network ] ]
n61=  set % [ $+ [ $network ] ] $1-
n62=}
n63=raw 005:*: {
n64=  set % [ $+ [ $network ] ] % [ $+ [ $network ] ] $1- 
n65=}
n66=;;stop NAMES spamming the server window...we're also caching it in a hashtable as well so we can search against it later.
n67=;;on ^*:join:#: { names $chan } ;;update names list on join
n68=raw 353:*: { 
n69=  ;;echo -s $1-
n70=  hinc -m [ $+($cid,.,$3) ] i
n71=  hadd -m [ $+($cid,.,$3) ] [ NameBuffer $+ [ $hget($+($cid,.,$3),i) ] ] $4-
n72=  haltdef
n73=}
n74=raw 366:*: {
n75=  haltdef 
n76=}
n77=
n78=;;Ping times to server.
n79=on *:connect: { 
n80=  timer 0 60 /tickping 
n81=  window -k2l20 $+(@lag,$network)
n82=}
n83=on ^*:PONG: { 
n84=  if ($1 == $server) {
n85=    aline -p $+(@lag,$network) $timestamp RTT(Ticks): $calc($ticks - $2) RTT(Sec): $calc($calc($ticks - $2) / 1000) 
n86=    aline -lp $+(@lag,$network) $timestamp $calc($calc($ticks - $2) / 1000)
n87=    set [ %lag $+ [ $network ] ] $calc($calc($ticks - $2) / 1000)
n88=  }
n89=  haltdef
n90=}
n91=
n92=
n93=;;Better Error handling, so we know when we accidentally send a command the server doesn't understand. 
n94=;;We may also try to shoehorn in some sort of lagtime measurements here, but I don't see why we should as /ping and server's pong works too
n95=raw 421:*: { 
n96=  echo -a ( Server ) 421: $2 $+ : $3-
n97=  haltdef
n98=}
n99=
n100=;;caching names data
n101=alias nametable {
n102=  var %i $hget($+($cid,.,$$1),i)
n103=  while (%i > 0) {
n104=    echo -a $$1 > $+(#,%i) > $+(NameBuffer,%i) > $hget($+($cid,.,$$1),$+(NameBuffer,%i))
n105=    dec %i
n106=  }
n107=}
n108=
n109=alias ntn {
n110=  if (isid) { 
n111=    return $hget($+($cid,.,$$1),$+(NameBuffer,$$2)) 
n112=    halt
n113=  }
n114=  echo -a $$1 > $$2 > $+(NameBuffer,$$2) > $hget($+($cid,.,$$1),$+(NameBuffer,$$2))
n115=}
n116=#rawhandlers end
n117=
n118=
n119=;; Smarter handling of sticky channels. We tell the client to send /detach for stuck chans. This gets us *out* of the channel quietly.
n120=;; Obviously, if you stick a channel; it must be added to %sticky so we know which channels to behave this way too. We may actually 
n121=;; need to add a bouncer detection too; but this can come later and we can just copy %sticky to %oldsticky and unset %sticky if we're connecting 
n122=;; directly instead of with the bouncer like normal. or we could just use a group. 
n123=
n124=#ZNCTweaks on
n125=alias part {
n126=  if ($1 isin %sticky) {
n127=    /detach $1
n128=  }
n129=  else { part $1- }
n130=}
n131=
n132=on me:ctcpreply:ZNC*: {
n133=  echo -a reply > $1-
n134=  if ($1) {
n135=    echo -a ZNC Detected!
n136=  }
n137=}
n138=#ZNCTweaks end
n139=
n140=#MassCommands on
n141=alias d {
n142=  detach $$1
n143=  var %i = $wildtok($1-,*,0,32)
n144=  while (%i > 1) {
n145=    detach [ [ $+($$,%i) ] ]
n146=    dec %i
n147=  }
n148=}
n149=
n150=alias j {
n151=  join $$1
n152=  var %i = $wildtok($1-,*,0,32)
n153=  while (%i > 1) {
n154=    join [ [ $+($$,%i) ] ]
n155=    dec %i
n156=  }
n157=}
n158=
n159=alias mv {
n160=  mode $chan $+(+,$str(v,4)) $$1-4
n161=  var %i = $wildtok($1-,*,0,32)
n162=  while (%i > 4) {
n163=    mode $chan +v [ [ $+($$,%i,-,$calc(%i-4)) ] ] 
n164=    dec %i
n165=  }
n166=}
n167=
n168=alias mdv {
n169=  mode $chan $+(-,$str(v,4)) $$1-4
n170=  var %i = $wildtok($1-,*,0,32)
n171=  while (%i > 4) {
n172=    mode $chan -v [ [ $+($$,%i,-,$calc(%i-4)) ] ]
n173=    dec %i
n174=  }
n175=}
n176=
n177=alias m+y {
n178=  mode $chan $+(+,$str(y,4)) $$1-4
n179=  var %i = $wildtok($1-,*,0,32)
n180=  while (%i > 4) {
n181=    mode $chan +y [ [ $+($$,%i,-,$calc(%i-4)) ] ]
n182=    dec %i
n183=  }
n184=}
n185=
n186=alias m-y {
n187=  mode $chan $+(-,$str(y,4)) $$1-4
n188=  var %i = $wildtok($1-,*,0,32)
n189=  while (%i > 4) {
n190=    mode $chan -y [ [ $+($$,%i,-,$calc(%i-4)) ] ]
n191=    dec %i
n192=  }
n193=}
n194=
n195=alias mq {
n196=  mode $chan $+(+,$str(q,4)) $$1-4
n197=  var %i = $wildtok($1-,*,0,32)
n198=  while (%i > 4) {
n199=    mode $chan +q [ [ $+($$,%i,-,$calc(%i-4)) ] ]
n200=    dec %i
n201=  }
n202=}
n203=
n204=alias mdq {
n205=  mode $chan $+(-,$str(q,4)) $$1-4
n206=  var %i = $wildtok($1-,*,0,32)
n207=  while (%i > 4) {
n208=    mode $chan -q [ [ $+($$,%i,-,$calc(%i-4)) ] ]
n209=    dec %i
n210=  }
n211=}
n212=
n213=alias ma {
n214=  mode $chan $+(+,$str(a,4)) $$1-4
n215=  var %i = $wildtok($1-,*,0,32)
n216=  while (%i > 4) {
n217=    mode $chan +a [ [ $+($$,%i,-,$calc(%i-4)) ] ]
n218=    dec %i
n219=  }
n220=}
n221=
n222=alias mda {
n223=  mode $chan $+(-,$str(a,4)) $$1-4
n224=  var %i = $wildtok($1-,*,0,32)
n225=  while (%i > 4) {
n226=    mode $chan -a [ [ $+($$,%i,-,$calc(%i-4)) ] ]
n227=    dec %i
n228=  }
n229=}
n230=
n231=alias mo {
n232=  mode $chan $+(+,$str(o,4)) $$1-4
n233=  var %i = $wildtok($1-,*,0,32)
n234=  while (%i > 4) {
n235=    mode $chan +o [ [ $+($$,%i,-,$calc(%i-4)) ] ]
n236=    dec %i
n237=  }
n238=}
n239=
n240=alias mdo {
n241=  mode $chan $+(-,$str(o,4)) $$1-4
n242=  var %i = $wildtok($1-,*,0,32)
n243=  while (%i > 4) {
n244=    mode $chan -o [ [ $+($$,%i,-,$calc(%i-4)) ] ]
n245=    dec %i
n246=  }
n247=}
n248=
n249=alias mh {
n250=  mode $chan $+(+,$str(h,4)) $$1-4
n251=  var %i = $wildtok($1-,*,0,32)
n252=  while (%i > 4) {
n253=    mode $chan +h [ [ $+($$,%i,-,$calc(%i-4)) ] ]
n254=    dec %i
n255=  }
n256=}
n257=
n258=alias mdq {
n259=  mode $chan $+(-,$str(h,4)) $$1-4
n260=  var %i = $wildtok($1-,*,0,32)
n261=  while (%i > 4) {
n262=    mode $chan -h [ [ $+($$,%i,-,$calc(%i-4)) ] ]
n263=    dec %i
n264=  }
n265=}
n266=
n267=alias mm {
n268=  var %i = $wildtok($2-,*,0,32)
n269=  while (%i > 1) {
n270=    mode $chan [ $+(+,$1) ] [ [ $+($$,%i) ] ]
n271=    dec %i
n272=  }
n273=}
n274=
n275=alias mdm {
n276=  var %i = $wildtok($1-,*,0,32)
n277=  while (%i > 1) {
n278=    mode $chan [ $+(-,$1) ] [ [ $+($$,%i) ] ]
n279=    dec %i
n280=  }
n281=}
n282=#MassCommands end
n283=
n284=#Notifyfix on
n285=alias monitor {
n286=  if ($network isin %nomon) {
n287=    watch $1-
n288=  }
n289=  else { monitor $1- }
n290=}
n291=
n292=#Notifyfix end
n293=
n294=#umodeghandler on
n295=;;Auto-accept users on voice in ##werewolf. 
n296=on ^*:voice:##werewolf: {
n297=  if ($vnick isin [ % $+ [ $network $+ . $+ accept ] ]) { halt }
n298=  /accept $vnick 
n299=  /accept *
n300=}
n301=;;Opers have auto /accept
n302=on ^*:voice:#freenode: {
n303=  if ($vnick isin [ % $+ [ $network $+ . $+ accept ] ]) { halt }
n304=  /accept $vnick 
n305=  /accept *
n306=}
n307=;;Freenode won't track nick changes for accept lists.
n308=on ^*:nick: { 
n309=  if ($newnick isin [ % $+ [ $network $+ . $+ accept ] ]) { halt }
n310=  if ($newnick isvoice ##werewolf) { /accept $newnick | /accept * }
n311=  if ($newnick isvoice #freenode) { /accept $newnick | /accept * }
n312=}
n313=raw 718:*: {
n314=  if ($2 ischan) { /accept $2 | /accept * }
n315=}
n316=raw 281:*: { set [ % $+ [ $network $+ . $+ accept ] ] $2- }
n317=#umodeghandler end
n318=
n319=#quietmodehandler on
n320=raw 728:*: { echo 7 $2 $+(+,$3) $4 by $5 on $asctime($6,mm/dd/yy @ hh:nn:sst) }
n321=raw 729:*: { echo 7 $2 $3- }
n322=#quietmodehandler end
